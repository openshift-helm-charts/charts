"""This file prepares the GitHub release and Index update steps.

All artifacts that go into a GitHub release are prepared:
* The report.yaml. If not provided by the user, a report has been generated at an
  earlier step and is included in the release.
* The public signing key, if provided by the user.
* The chart's sources, if provided by the user.
* The provenance file, if provided by the user.

A GitHub release will be created in a later step, if the user hasn't selected the "Web
Catalog Only" option.

An Index entry is prepared for this chart and version, either:
* Crafted from the Chart.yaml, if the chart's sources have been provided by the user.
* Prepared from scratch using information from the report.yaml.

The index entry and chart URL are made available as GitHub outputs and the actual index
update occurs in a later step.

"""

import argparse
import base64
import json
import os
import re
import shutil
import subprocess
import sys
import tempfile
import time
import urllib.parse

import yaml
from environs import Env

try:
    from yaml import CDumper as Dumper
    from yaml import CSafeLoader as SafeLoader
except ImportError:
    from yaml import Dumper, SafeLoader

sys.path.append("../")
from pullrequest import prartifact
from reporegex import matchers
from report import report_info
from signedchart import signedchart
from tools import gitutils

from chartrepomanager import indexannotations


def _encode_chart_entry(chart_entry):
    """Encode the chart_entry to base64. This is needed to pass it as an argument to
    the update index step.

    Args:
        chart_entry (dict): the index entry for this chart to encode

    Returns:
        str: The encoded base64 string equivalent.

    """
    chart_entry_str = json.dumps(chart_entry)
    chart_entry_bytes = chart_entry_str.encode()

    # Decoding to string for the GITHUB_OUTPUT
    return base64.b64encode(chart_entry_bytes).decode()


def get_modified_charts(api_url):
    """Get the category, organization, chart name, and new version corresponding to
    the chart being added or modified by this PR.

    Args:
        api_url (str): URL of the GitHub PR

    Returns:
        (str, str, str, str): category, organization, chart, and version (e.g. partner,
                              hashicorp, vault, 1.4.0)
    """
    files = prartifact.get_modified_files(api_url)
    pattern = re.compile(
        matchers.submission_path_matcher(strict_categories=False) + r"/.*"
    )
    for file_path in files:
        m = pattern.match(file_path)
        if m:
            category, organization, chart, version = m.groups()
            return category, organization, chart, version

    print("No modified files found.")
    sys.exit(0)


def check_chart_source_or_tarball_exists(category, organization, chart, version):
    """Check if the chart's source or chart's tarball is present

    Args:
        category (str): Type of profile (community, partners, or redhat)
        organization (str): Name of the organization (ex: hashicorp)
        chart (str): Name of the chart (ex: vault)
        version (str): The version of the chart (ex: 1.4.0)

    Returns:
        (bool, bool): First boolean indicates the presence of the chart's source
                      Second boolean indicates the presence of the chart's tarball
    """
    src = os.path.join("charts", category, organization, chart, version, "src")
    if os.path.exists(src):
        return True, False

    tarball = os.path.join(
        "charts", category, organization, chart, version, f"{chart}-{version}.tgz"
    )
    if os.path.exists(tarball):
        return False, True

    return False, False


def check_report_exists(category, organization, chart, version):
    """Check if a report was provided by the user

    Args:
        category (str): Type of profile (community, partners, or redhat)
        organization (str): Name of the organization (ex: hashicorp)
        chart (str): Name of the chart (ex: vault)
        version (str): The version of the chart (ex: 1.4.0)

    Returns:
        (bool, str): a boolean set to True if the report.yaml file is present, and the
                     path to the report.yaml file.
    """
    report_path = os.path.join(
        "charts", category, organization, chart, version, "report.yaml"
    )
    return os.path.exists(report_path), report_path


def generate_report():
    """Creates report file using the content generated by chart-pr-review

    Returns:
        str: Path to the report.yaml file.
    """
    cwd = os.getcwd()
    report_content = urllib.parse.unquote(os.environ.get("REPORT_CONTENT"))
    print("[INFO] Report content:")
    print(report_content)
    report_path = os.path.join(cwd, "report.yaml")
    with open(report_path, "w") as fd:
        fd.write(report_content)
    return report_path


def prepare_chart_source_for_release(category, organization, chart, version):
    """Create an archive file of the Chart for the GitHub release.

    When the PR contains the chart's source, we package it using "helm package" and
    place the archive file in the ".cr-release-packages" directory. This directory will
    contain all assets that should be uploaded as a GitHub Release.

    Args:
        category (str): Type of profile (community, partners, or redhat)
        organization (str): Name of the organization (ex: hashicorp)
        chart (str): Name of the chart (ex: vault)
        version (str): The version of the chart (ex: 1.4.0)
    """
    print(
        "[INFO] prepare chart source for release. %s, %s, %s, %s"
        % (category, organization, chart, version)
    )
    path = os.path.join("charts", category, organization, chart, version, "src")
    out = subprocess.run(["helm", "package", path], capture_output=True)
    print(out.stdout.decode("utf-8"))
    print(out.stderr.decode("utf-8"))
    chart_file_name = f"{chart}-{version}.tgz"
    try:
        os.remove(os.path.join(".cr-release-packages", chart_file_name))
    except FileNotFoundError:
        pass
    shutil.copy(f"{chart}-{version}.tgz", f".cr-release-packages/{chart_file_name}")


def prepare_chart_tarball_for_release(
    category, organization, chart, version, signed_chart
):
    """Move the provided tarball (and signing key if needed) to the release directory

    The tarball is moved to the ".cr-release-packages" directory. If the archive has
    been signed with "helm package --sign", the provenance file is also included.

    Args:
        category (str): Type of profile (community, partners, or redhat)
        organization (str): Name of the organization (ex: hashicorp)
        chart (str): Name of the chart (ex: vault)
        version (str): The version of the chart (ex: 1.4.0)
        signed_chart (bool): Set to True if the tarball chart is signed.

    Returns:
        str: Path to the public key file used to sign the tarball
    """
    print(
        "[INFO] prepare chart tarball for release. %s, %s, %s, %s"
        % (category, organization, chart, version)
    )
    chart_file_name = f"{chart}-{version}.tgz"
    # Path to the provided tarball
    path = os.path.join(
        "charts", category, organization, chart, version, chart_file_name
    )
    try:
        os.remove(os.path.join(".cr-release-packages", chart_file_name))
    except FileNotFoundError:
        pass
    shutil.copy(path, f".cr-release-packages/{chart_file_name}")
    shutil.copy(path, chart_file_name)

    if signed_chart:
        print("[INFO] Signed chart - include PROV file")
        prov_file_name = f"{chart_file_name}.prov"
        path = os.path.join(
            "charts", category, organization, chart, version, prov_file_name
        )
        try:
            os.remove(os.path.join(".cr-release-packages", prov_file_name))
        except FileNotFoundError:
            pass
        shutil.copy(path, f".cr-release-packages/{prov_file_name}")
        shutil.copy(path, prov_file_name)
        gitutils.add_output(
            "prov_file_name",
            os.path.join(os.getcwd(), ".cr-release-packages", prov_file_name),
        )
        return get_key_file(category, organization, chart, version)
    return ""


def get_key_file(category, organization, chart, version):
    owners_path = os.path.join("charts", category, organization, chart, "OWNERS")
    key_in_owners = signedchart.get_pgp_key_from_owners(owners_path)
    if key_in_owners:
        key_file_name = f"{chart}-{version}.tgz.key"
        print(f"[INFO] Signed chart - add public key file : {key_file_name}")
        signedchart.create_public_key_file(key_in_owners, key_file_name)
        return key_file_name
    return ""


def create_index_from_chart(chart_file_name):
    """Prepare the index entry for this chart

    Given that a chart tarball could be created (i.e. the user provided either the
    chart's source or tarball), the content of Chart.yaml is used for the index entry.

    Args:
        chart_file_name (str): Name of the chart's archive

    Returns:
        dict: content of Chart.yaml, to be used as index entry.
    """
    print("[INFO] create index from chart. %s" % (chart_file_name))
    out = subprocess.run(
        [
            "helm",
            "show",
            "chart",
            os.path.join(".cr-release-packages", chart_file_name),
        ],
        capture_output=True,
    )
    p = out.stdout.decode("utf-8")
    print(p)
    print(out.stderr.decode("utf-8"))
    crt = yaml.load(p, Loader=SafeLoader)
    return crt


def create_index_from_report(category, ocp_version_range, report_path):
    """Prepare the index entry for this chart.

    In the case only a report was provided by the user, we need to craft an index entry
    for this chart.

    To that end, this function performs the following actions:
    * Get the list of annotations from report file
    * Override / set additional annotations:
        * Replaces the certifiedOpenShiftVersions annotation with the
          testedOpenShiftVersion annotation.
        * Adds supportedOpenShiftVersions if not already set.
        * Adds (overrides) providerType.
    * Use report.medatata.chart as a base for the index entry
    * Merge (override) annotations into the index entry' annotations
    * Add digest to index entry if known.

    Args:
        category (str): Type of profile (community, partners, or redhat)
        ocp_version_range (str): Range of supported OCP versions
        report_path (str): Path to the report.yaml file

    Returns:
        dict: Index entry for this chart

    """
    print(
        "[INFO] create index from report. %s, %s, %s"
        % (category, ocp_version_range, report_path)
    )

    annotations = indexannotations.getIndexAnnotations(ocp_version_range, report_path)

    print("category:", category)
    redhat_to_community = bool(os.environ.get("REDHAT_TO_COMMUNITY"))
    if category == "partners":
        annotations["charts.openshift.io/providerType"] = "partner"
    elif category == "redhat" and redhat_to_community:
        annotations["charts.openshift.io/providerType"] = "community"
    else:
        annotations["charts.openshift.io/providerType"] = category

    chart_entry = report_info.get_report_chart(report_path)
    if "annotations" in chart_entry:
        annotations = chart_entry["annotations"] | annotations

    chart_entry["annotations"] = annotations

    digests = report_info.get_report_digests(report_path)
    if "package" in digests:
        chart_entry["digest"] = digests["package"]

    return chart_entry


def update_chart_annotation(
    category, organization, chart_file_name, chart, ocp_version_range, report_path
):
    """Untar the helm release that was placed under .cr-release-packages, update the
    chart's annotations, and repackage the Helm release.

    In particular, following manipulations are performed on annotations:
    * Gets the dict of annotations from the report file.
    * Replaces the certifiedOpenShiftVersions annotation with the
    testedOpenShiftVersion annotation.
    * Adds supportedOpenShiftVersions if not already set.
    * Adds (overrides) providerType.
    * Adds provider if not already set.
    * Merge (overrides) those annotations into the Chart's annotations.

    Args:
        category (str): Type of profile (community, partners, or redhat)
        organization (str): Name of the organization (ex: hashicorp)
        chart_file_name (str): Name of the chart's archive
        chart (str): Name of the chart (ex: vault)
        ocp_version_range (str): Range of supported OCP versions
        report_path (str): Path to the report.yaml file
    """
    print(
        "[INFO] Update chart annotation. %s, %s, %s, %s, %s"
        % (category, organization, chart_file_name, chart, ocp_version_range)
    )
    dr = tempfile.mkdtemp(prefix="annotations-")

    annotations = indexannotations.getIndexAnnotations(ocp_version_range, report_path)

    print("category:", category)
    redhat_to_community = bool(os.environ.get("REDHAT_TO_COMMUNITY"))
    if category == "partners":
        annotations["charts.openshift.io/providerType"] = "partner"
    elif category == "redhat" and redhat_to_community:
        annotations["charts.openshift.io/providerType"] = "community"
    else:
        annotations["charts.openshift.io/providerType"] = category

    if "charts.openshift.io/provider" not in annotations:
        data = open(
            os.path.join("charts", category, organization, chart, "OWNERS")
        ).read()
        out = yaml.load(data, Loader=SafeLoader)
        vendor_name = out["vendor"]["name"]
        annotations["charts.openshift.io/provider"] = vendor_name

    out = subprocess.run(
        [
            "tar",
            "zxvf",
            os.path.join(".cr-release-packages", f"{chart_file_name}"),
            "-C",
            dr,
        ],
        capture_output=True,
    )
    print(out.stdout.decode("utf-8"))
    print(out.stderr.decode("utf-8"))

    fd = open(os.path.join(dr, chart, "Chart.yaml"))
    data = yaml.load(fd, Loader=SafeLoader)

    if "annotations" not in data:
        data["annotations"] = annotations
    else:
        # merge the existing annotations with our new ones, overwriting
        # values for overlapping keys with our own.
        # Overwriting is important because the chart may contain values that we
        # must override, such as the providerType which changes in redhat-to-community cases.
        # |= syntax requires py3.9
        data["annotations"] |= annotations
    out = yaml.dump(data, Dumper=Dumper)
    with open(os.path.join(dr, chart, "Chart.yaml"), "w") as fd:
        fd.write(out)

    out = subprocess.run(
        ["helm", "package", os.path.join(dr, chart)], capture_output=True
    )
    print(out.stdout.decode("utf-8"))
    print(out.stderr.decode("utf-8"))

    try:
        os.remove(os.path.join(".cr-release-packages", chart_file_name))
    except FileNotFoundError:
        pass

    shutil.move(chart_file_name, ".cr-release-packages")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-r",
        "--repository",
        dest="repository",
        type=str,
        required=True,
        help="Git Repository",
    )
    parser.add_argument(
        "-u",
        "--api-url",
        dest="api_url",
        type=str,
        required=True,
        help="API URL for the pull request",
    )
    args = parser.parse_args()
    category, organization, chart, version = get_modified_charts(args.api_url)
    chart_source_exists, chart_tarball_exists = check_chart_source_or_tarball_exists(
        category, organization, chart, version
    )

    env = Env()
    web_catalog_only = env.bool("WEB_CATALOG_ONLY", False)
    ocp_version_range = os.environ.get("OCP_VERSION_RANGE", "N/A")

    print(f"[INFO] webCatalogOnly/providerDelivery is {web_catalog_only}")

    public_key_file = ""
    print("[INFO] Report Content : ", os.environ.get("REPORT_CONTENT"))
    if chart_source_exists or chart_tarball_exists:
        if chart_source_exists:
            prepare_chart_source_for_release(category, organization, chart, version)
        if chart_tarball_exists:
            signed_chart = signedchart.is_chart_signed(args.api_url, "")
            public_key_file = prepare_chart_tarball_for_release(
                category, organization, chart, version, signed_chart
            )

        chart_file_name = f"{chart}-{version}.tgz"
        tarball_path = os.path.join(
            os.getcwd(), ".cr-release-packages", chart_file_name
        )
        gitutils.add_output("path_to_chart_tarball", tarball_path)

        print("[INFO] Check if report exist as part of the commit")
        report_exists, report_path = check_report_exists(
            category, organization, chart, version
        )

        if report_exists:
            shutil.copy(report_path, "report.yaml")
        else:
            print("[INFO] Generate report")
            report_path = generate_report()

        print("[INFO] Updating chart annotation")
        update_chart_annotation(
            category,
            organization,
            chart_file_name,
            chart,
            ocp_version_range,
            report_path,
        )
        chart_url = f"https://github.com/{args.repository}/releases/download/{organization}-{chart}-{version}/{chart_file_name}"
        print("[INFO] Creating index from chart")
        chart_entry = create_index_from_chart(chart_file_name)
    else:
        report_path = os.path.join(
            "charts", category, organization, chart, version, "report.yaml"
        )
        print(f"[INFO] Report only PR: {report_path}")
        shutil.copy(report_path, "report.yaml")
        if signedchart.check_report_for_signed_chart(report_path):
            public_key_file = get_key_file(category, organization, chart, version)
        print("[INFO] Creating index from report")
        chart_url = report_info.get_report_chart_url(report_path)
        chart_entry = create_index_from_report(category, ocp_version_range, report_path)

    if not web_catalog_only:
        current_dir = os.getcwd()
        gitutils.add_output("report_file", f"{current_dir}/report.yaml")
        if public_key_file:
            print(f"[INFO] Add key file for release : {current_dir}/{public_key_file}")
            gitutils.add_output("public_key_file", f"{current_dir}/{public_key_file}")

    gitutils.add_output("chart_entry", _encode_chart_entry(chart_entry))
    gitutils.add_output("chart_url", chart_url)
    gitutils.add_output("version", version)

    print("Sleeping for 10 seconds")
    time.sleep(10)
